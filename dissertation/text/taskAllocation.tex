\chapter{Task Allocation}
\label{sec:uncoordTasking}

Assigning tasks amongst a group of workers is a well known problem with many facets and variants.  In our case we have a group of UAVs flying around with different capabilities.  The UAVs coordinate and cooperate but there is no centralized controller or manager.   In theory having a centralized controller with perfect information could produce the most optimal configuration of task allocations for the entire swarm.  In practice achieving such a system is difficult since it requires a large amount of communication and introduces a single point of failure.  Algorithms that create an optimal solution given perfect information can take a long time to run.  So even if we have a suitable communications network the responsiveness of the centralized controller introduces another potential problem especially as the size of the swarm or number of potential tasks increases.

Fully decentralized controllers cannot guarantee perfectly optimal task allocations but they can usually provide ``good enough'' allocations.  An example of this is proven in~\cite{auction_linear_approx} where the distributed algorithm came within a linear approximation of the perfect global optimum solution.  Decentralized controllers use imperfect local knowledge and can operate very fast in comparison to centralized controllers due to their inherent parallelism.  Decentralized controllers also offer failure redundancy and reductions in performance requirements of the communications network.

Two common approaches to distributed task allocation are market based algorithms and behavioral algorithms.  On the spectrum from fully centralized to fully decentralized these algorithms lie somewhere in the middle in order to capitalize on the strengths of both approaches.

\section{Market based allocation}

The Auction Algorithm borrows concepts from economics to model an auction as its name implies.  A centralized version was proposed in in~\cite{auction_derive} and enhanced in later revisions by the same author.  The author created a distributed version of the Auction Algorithm in~\cite{auction_parallel}.  The algorithm requires an agent to start an auction for some task to be completed.  Typically the agent that first detects a task starts the auction.  The agent broadcasts out a message with details about the task to the swarm.  Other agents then formulate a bid for the task and send their responses back to the auctioning agent.  The auctioneer waits for the bid responses and analyzes them.  The auctioneer could declare a winner or it could rebroadcast the current best bid and wait again for further responses with higher bids.  

This is a generic description of the Auction Algorithm.  There are many variants and derivatives that change how bids are generated, how the auction is closed, and how to handle communication failures.  There are even variants to allow multiple agents to perform a task together as a team in~\cite{auction_team}.  The core feature of the algorithm is the temporary centralized auctioneer per newly discovered task.  For this to work the auctioneer must to be able to communicate with local agents and be able to compare their bid responses.  It also requires each agent to understand what it takes to accomplish every possible task.

Another market based system is the Contract Net protocol first introduced in~\cite{contract_net}.  It could be considered a specialization or superset of the Auction Algorithm.  This protocol breaks a task into subtasks and allows each subtask to be auctioned independently. It defines a meta-language within the allocation process for describing tasks and the resources required to complete them.  It provides mechanisms for reporting on the status of tasks and returning information once a task in complete.  This allows more cooperation between agents and a potential for better global optimization since each sub-task can be performed by the best agent available instead of a single agent performing all subtasks within a task.  The trade-off for this better global optimum performance is a requirement for more communication to handle the subtask allocation and coordination.  As with the Auction Algorithm many variants of the Contract Net protocol have been created as described in~\cite{contract_survey} and ~\cite{contract_equity}.

In both market based systems there is a temporary communications channel and messaging sequence to support task allocation.

\section{Behavior based allocation}

Behavior based algorithms are algorithmic representations of phenomenon seen in humans and animals. They differ from the market based solutions in that agents ``take'' or ``volunteer'' for a task instead of being ``assigned'' a task.  For example in~\cite{ant_colony_opt} a team of robots cooperated in a fully decentralized fashion and used the Ant Colony Optimization(~\cite{wiki:aco}) algorithm for task allocation.  All of the robots were identical in form and function.  Tasks could require one or more robots.  Each robot used its own sensors to create a model of the environment and to generate a list of tasks to be accomplished.  A robot would then move about and observe a task.  It would then determine if enough robots were simultaneously working on a task together.  If not then it would join in the effort otherwise it continued onto another task in the environment.  In this case no active communication occurred and tasks were passively taken.

Stigmergy is another common behavior based system.  In stigmergic systems data is not directly passed from one agent to the next.  Instead the environment is modified by the agents and in doing so data is encoded.  Other agents who then observe the modified environment will learn about the data left behind from the previous agent.  In~\cite{stigmergy_building} a swarm of agents moved 2D blocks around to create a 2D structure.  No direct communication between the agents occurred.  Instead the agents were all programmed with rules indicating if they did not have a block that they should find one and if they have a block then they should find another collection of blocks that match some known pattern in their memory.  Once they found a pattern they dropped the block they were carrying to extend the collection or pattern.  In this fashion jumbled piles of blocks were turned into 2D structures.  In this case no active communication occurred and tasks were passively taken.

Another common example of behavior based task allocation are pheromone systems.  In these systems agents of the swarm deposit a physical or virtual pheromone at a location.  The type of pheromone deposited indicates the type of task that can be performed at the location.  Over time these pheromones decay and disappear or seep into nearby locations.  The seepage of pheromones into nearby locations helps agents find and perform tasks by following the gradient of the pheromone's strength.  As with the other task allocation algorithms there are many variants and techniques for handling the details of the pheromone system.  In~\cite{pheromone} an ant colony was modeled in that the agents left the nest and foraged for food.  As the agents explored they left behind a ``to nest'' pheromone.  This pheromone helped guide the ant agents back to the nest.  When the ant agents found a source of food they would deposit a ``to food'' pheromone.  When the food carrying agents made it back to the nest by following the ``to nest'' gradient other ants would notice the newly deposited ``to food'' pheromone.  The other agents would then follow the ``to food'' pheromone to the food source and return to the nest therefore restrengthening the ``to food'' pheromone creating a positive feedback loop.  A pheromone system like this can be modeled with literal real chemical pheromones left behind by robotic agents.  It can also be modeled virtually by agents broadcasting a pheromone strength number in their belief models that are communicated with the rest of the swarm.  In this case active communication is used but tasks are passively acted upon by volunteers instead of being assigned.\todo{Discuss TRA.pdf? Motivational behaviors?}

\section{WORKING TITLE: My Allocator}\todo{Needs a name}

The allocation scheme used in this work is more closely aligned to the fully decentralized end of the spectrum.  If other agents exist within communications range they will share their belief models but they will not otherwise directly engage or seek each other.  Periodically agents analyze their belief model to find the best action they can do.  There are only two strongly enforced rules to control who performs a particular task.  

\begin{enumerate}
	\item The agent with the best Monitor or Attack score in the Target Belief data structure gets to perform the task.
	\item Once an Attack task's state is set to \textit{Performing} no other agent may claim the task regardless of rule 1.
\end{enumerate}

Rule 1 states that a ``survival of the fittest'' situation occurs.  If multiple UAVs compete for the same task then the strongest agent wins the task.  Scores are computed based on the UAV's ability to perform the task and their current distance from the task.  While it is theoretically possible for ties in scoring to occur in practice it is inconsequential.  The ability to perform a task has many variables and distances to the targets are always changing.  Each UAV's score will change slightly at the next periodic update.

When a task's state changes to \textit{NO TASK}, \textit{Open}, or \textit{Enroute} any UAV may attempt to claim it.  Claiming occurs when an agent is close enough to begin performing the action and they set the Task State to \textit{Performing}.  An agent may choose to stop performing a task by resetting the task's state to \textit{Open}.  When an agent claims an attack task rule 2 comes into affect and no other UAV may take the task.  UAVs performing the Monitor task may be overridden if another UAV comes within range with a significantly better score.  The definition of significantly better is definable by the operator as a percentage.   This helps to prevent churn in the monitoring process but allows a much better sensor to be utilized if it presents itself.  Either way, someone is always watching the target.\todo{write out algorithm for task claiming}

These rules only work in an environment where no agent lies.  An agent can have out of date information and faulty sensors but they cannot actively lie.  All information is timestamped using a synchronized clock so stale data is a recoverable error and accounted for in all comparison and merging processes.  Faulty sensors can be overcome by other members of the swarm repeatedly contradicting the bad data.

Tasks start in the \textit{NO TASK} state when they are first discovered.  The discovering agent will add the task to their belief model and broadcast it out locally.  Other agents may hear about the new task and rebroadcast it out again when they next transmit their belief model.  In this fashion the task will propagate through the network.  However, there is a latency in the logic processing between agents near the task and those farther away.  It takes time for the task to hop from the interior to the exterior of the swarm.  During this timespan agents closer to the task may already begin to posture to claim it while those farther away are just first hearing about it.  There is a weighting factor set by the operator to specify if they prefer the closest UAV to perform the task or if they prefer the best equipped UAV to perform the task.  This weighting factor allows UAVs far away from the initial task announcement a chance to claim the task.

When a UAV thinks it can claim a task it sets the Target Belief data with the computed score, the UAV's ID, and sets the Task State to Enroute.  Other UAVs will hear these updates at the next periodic belief model broadcast.  Simultaneously other UAVs could believe they will claim the task as well and eventually multiple UAVs could arrive near the task.  While they are all enroute their beliefs propagate through the network and merge with others.  Eventually some of the UAVs will hear that they are not the best suited for the task and will go find some other task to perform.  This competition period emulates the centralized controller strength in that someone coordinates who gets to perform the task.  In this case the centralized controller changes swiftly based on who the dominant UAV is at the time.  The dominant UAV effectively guards their territory like an animal until a stronger one appears.

This simple ``survival of the fittest'' mechanism has many benefits.  Very little communication is required and no bidirectional communication occurs at all.  UAVs share their belief model of the world which is just a static data dump with well defined merging procedures.  Other UAVs hear this whole data packet or they hear nothing at all.  There is no need to maintain and manage temporary communication channels to facilitate negotiations or transactions like in market based algorithms.  This mechanism is most closely related to pheromone models with the addition that agents know who laid down the pheromone.  Each UAV has their own unique pheromone signature.  This means the control laws for guiding the aircraft consolidate down to a series of strength comparisons with no higher level logic.  The formal algorithm for this task allocation scheme is written in~\ref{alg:taskAlloc}.\todo{This is the whole point of thesis}
