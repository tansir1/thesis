\chapter{Task Allocation}
\label{sec:uncoordTasking}

Assigning tasks amongst a group of workers is a well known problem with many facets and variants.  In our case we have a group of UAVs flying around with different capabilities.  The UAVs coordinate and cooperate but there is no centralized controller or manager.   In theory having a centralized controller with perfect information could produce the most optimal configuration of task allocations for the entire swarm.  In practice achieving such a system is difficult since it requires a large amount of communication and introduces a single point of failure.  Algorithms that create an optimal solution given perfect information can take a long time to run.  So even if we have a suitable communications network the responsiveness of the centralized controller introduces another potential problem especially as the size of the swarm or number of potential tasks increases.

Fully decentralized controllers cannot guarantee perfectly optimal task allocations but they can usually provide ``good enough'' allocations.  An example of this is proven in~\cite{auction_linear_approx} where the distributed algorithm came within a linear approximation of the perfect global optimum solution.  Decentralized controllers use imperfect local knowledge and can operate very fast in comparison to centralized controllers due to their inherent parallelism.  Decentralized controllers also offer failure redundancy and reductions in performance requirements of the communications network.  It's possible a communication network may not be needed at all as with stigmergic systems.

Two common approaches to distributed task allocation are market based algorithms and behavioral algorithms.  On the spectrum from fully centralized to fully decentralized these algorithms lie somewhere in the middle in order to capitalize on the strengths of both approaches.

\section{Market based allocation}

The Auction Algorithm borrows concepts from economics to model an auction as its name implies.  A centralized version was proposed in in~\cite{auction_derive} and enhanced in later revisions by the same author.  The author created a distributed version of the Auction Algorithm in~\cite{auction_parallel}.  The algorithm requires an agent to start an auction for some task to be completed.  Typically the agent that first detects a task that needs to be complete starts the auction.  The agent broadcasts out a message with details about the task to the swarm.  Other agents then formulate a bid for the task and send their responses back to the auctioning agent.  The auctioneer waits for the bid responses and analyzes them.  The auctioneer could declare a winner or it could rebroadcasts the current best bid and wait again for further responses with higher bids.  

This is a generic description of the Auction Algorithm.  There are many variants and derivatives that change how bids are generated, how the auction is closed, and how to handle communication failures.  There are even variants to allow multiple agents to perform a task together as a team in~\cite{auction_team}.  The core feature of the algorithm is the temporary centralized auctioneer per newly discovered task.  For this to work the auctioneer must to be able to communicate with local agents and be able to compare their bid responses.  It also requires each agent to understand what it takes to accomplish every possible task.


Another market based system is the Contract Net protocol first introduced in~\cite{contract_net}.  It could be considered a specialization or superset of the Auction Algorithm.  This protocol breaks a task into subtasks and allows each subtask to be auctioned independently. It defines a meta-language within the allocation process for describing tasks and the resources required to complete them.  It provides mechanisms for reporting on the status of tasks and returning information once a task in complete.  This allows more cooperation between agents and a potential for better global optimization since each sub-task can be performed by the best agent available instead of a single agent performing all subtasks within a task.  The trade-off for this better global optimum performance is a requirement for more communication to handle the subtask allocation and coordination.  As with the Auction Algorithm many variants of the Contract Net protocol have been created as described in~\cite{contract_survey} and ~\cite{contract_equity}.

\section{Behavior based allocation}

Behavior based algorithms are algorithmic representations of phenomenon seen in humans and animals. They differ from the market based solutions in that agents ``take'' or ``volunteer'' for a task instead of being ``assigned'' a task.  For example in~\cite{ant_colony_opt} a team of robots cooperated in a fully decentralized fashion and used the Ant Colony Optimization(~\cite{wiki:aco}) algorithm for task allocation.  All of the robots were identical in form and function.  Tasks could require one or more robots.  Each robot used its own sensors to create a model of the environment and to generate a list of tasks to be accomplished.  A robot would then move about and observe a task.  It would then determine if enough robots were simultaneously working on a task together.  If not then it would join in the effort otherwise it continued onto another task in the environment.  In this case no active communication occurred and tasks were passively taken.

Stigmergy is another common behavior based system.  In stigmergic systems data is not directly passed from one agent to the next.  Instead the environment is modified by the agents and in doing so data is encoded.  Other agents who then observe the modified environment will learn about the data left behind from the previous agent.  In~\cite{stigmergy_building} a swarm of agents moved 2D blocks around to create a 2D structure.  No direct communication between the agents occurred.  Instead the agents were all programmed with rules indicating if they did not have a block that they should find one and if they have a block then they should find another collection of blocks that match some known pattern in their memory.  Once they found a pattern they dropped the block they were carrying to extend the collection or pattern.  In this fashion jumbled piles of blocks were turned into 2D structures.  In this case no active communication occurred and tasks were passively taken.

Another common example of behavior based task allocation are pheromone systems.  In these systems agents of the swarm deposit a physical or virtual pheromone at a location.  The type of pheromone deposited indicates the type of task that can be performed at the location.  Over time these pheromones decay and disappear or seep into nearby locations.  The seepage of pheromones into nearby locations helps agents find and perform tasks by following the gradient of the pheromone's strength.  As with the other task allocation algorithms there are many variants and techniques for handling the details of the pheromone system.  In~\cite{pheromone} an ant colony was modeled in that the agents left the nest and foraged for food.  As the agents explored they left behind a ``to nest'' pheromone.  This pheromone helped guide the ant agents back to the nest.  When the ant agents found a source of food they would deposit a ``to food'' pheromone.  When the food carrying agents made it back to the nest by following the ``to nest'' gradient other ants would notice the newly deposited ``to food'' pheromone.  The other agents would then follow the ``to food'' pheromone to the food source and return to the nest therefore restrengthening the ``to food'' pheromone creating a positive feedback loop.  A pheromone system like this can obviously be modeled with literal real chemical pheromones left behind by robotic agents.  It can also be modeled virtually by agents broadcasting a pheromone strength number in their belief models that are communicated with the rest of the swarm.  In this case active communication is used but tasks are passively taken instead of being assigned.

\todo{FINISH ME!}
Describe the TRA.pdf 
motivational factors suggest ot the agent to do something.  Not assigned antyhing actively.  Similarities to my model.

Compare and contrast communication and processing requirements with market approach.







 in . Due to the desire for real world applicability of the algorithms presented here complex evaluation or large data packets were shunned. It is inspired