\chapter{Appendix}

%------------------------------------------------------------------------------

\section{Dubin's Path} \label{sec:dubin}
The movement of UAVs is constrained to a continuous path with constant speed.

%------------------------------------------------------------------------------

\section{Monitor Sub-states}
\label{sec:monitorSubStates}
\begin{figure}[h]
	\centering
	%\includegraphics[width=\linewidth,height=\textheight]{imagefile}
	\includegraphics[scale=0.6]{uav_monitor_states.png}
	%	\includegraphics{uav_monitor_states.png}
	\caption{Monitor sub-states}
	\label{fig:monitor}
\end{figure}

%------------------------------------------------------------------------------
\section{Attack Activity Diagram}
\label{sec:attackActivity}
\begin{figure}[h]
	\centering
	%\includegraphics[width=\linewidth,height=\textheight]{imagefile}
	\includegraphics[scale=0.6]{uav_activity_attack.png}
	\caption{UAV Attack Activity}
	\label{fig:uavAttackActivity}
\end{figure}

%------------------------------------------------------------------------------

\section{Sample Payload Configurations}
\label{sec:pyldConfigs}
\begin{table}[h]
	\caption{UAV sensor payload configuration}
	\centering
	\rowcolors{1}{lightgray}{white}
	\label{tab:uavSensorMap}
	\begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|}
		\hline
		UAV Type & Sensor Type\\ \hline
		0 & 1 \\
		1 & 0 \\
		\hline
	\end{tabular}
\end{table}

\begin{table}[h]
	\caption{UAV weapon payload configuration}
	\centering
	\rowcolors{1}{lightgray}{white}
	\label{tab:uavWpnMap}
	\begin{tabular}{|p{1cm}|p{1.5cm}|p{2cm}|}
		\hline
		UAV Type & Weapon Type & Initial Quantity\\ \hline
		0 & 0 & 2 \\
		0 & 1 & 2 \\
		1 & 0 & 5 \\
		1 & 1 & 5 \\
		\hline
	\end{tabular}
\end{table}

%------------------------------------------------------------------------------

\section{Algorithms}
\label{sec:algorithms}

\begin{algorithm}
	\caption{UAV Foraging - Selecting a cell to search}
	\label{alg:forage}
	\begin{algorithmic}[1]
		\Function{GenerateForageLocation}{}
			\Require $ 0\le randomWeighting \le 1$
			\Require $ kernelSize \ll min($number world rows, number world columns$)$
			\Require $ \frac{number world rows}{kernelSize} \in Z$
			\Require $ \frac{number world columns}{kernelSize} \in Z$
			\Ensure $ 0 \le x \le $ number world rows
			\Ensure $ 0 \le y \le $ number world columns
			\State $rowsPerKernel\gets $ number world rows $ / kernelSize$
			\State $colsPerKernel\gets $ number world columns $ / kernelSize$		
			\State $x\gets -1$
			\State $y\gets -1$
			\State $maxUncertainty\gets -1$
			\State $maxUncertRow\gets -1$
			\State $maxUncertCol\gets -1$
			
			
			\If{$random() < randomWeighting$}
				\State $ y\gets $ random row
				\State $ x\gets $ random column
			\Else
				\For{$i\gets0$, $i < $number world rows, $i\gets i + rowsPerKernel$}
					\For{$j\gets0$, $j <$ number world columns, $j\gets j + colsPerKernel$}
						\State $kernelUncert\gets computeKernelUncert(i,j, kernelSize)$
						\If{$kernelUncert > maxUncertainty$}
							\State $maxUncertainty\gets kernelUncert$
							\State $maxUncertRow\gets i$
							\State $maxUncertCol\gets j$	
						\EndIf
					\EndFor
				\EndFor
				\State $x\gets randomInteger(rowPerKernel) + maxUncertRow$			
				\State $y\gets randomInteger(colsPerKernel) + maxUncertCol$
			\EndIf \\
			
			\Return x, y
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Cell Belief Merging}
	\label{alg:mergeCell}
	\begin{algorithmic}[1]
		\Function{MergeCells}{$myCells[][], otherCells[][]$}
		\State $numRows\gets $ number of world rows
		\State $numCols\gets $ number of world columns
		\State $alpha\gets $ user defined weighting value in [0,1]
		\For{$i\gets 0, numRows$}
			\For{$j\gets 0, numCols$}
				\If{$otherCells_{ij}.lastUpdateTime > myCells_{ij}.lastUpdateTime$}
					\State $myCells_{ij}.probCellEmpty\gets alpha * otherCells_{ij}.probCellEmpty + (1-alpha) * myCells_{ij}.probCellEmpty$
					\State $myCells_{ij}.lastUpdateTime\gets otherCells_{ij}.lastUpdateTime$
				\EndIf
			\EndFor
		\EndFor
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Target Belief Merging}
	\label{alg:mergeTarget}
	\begin{algorithmic}[1]
		\Function{MergeTargets}{$myTarget, otherTarget$}
		\State $alpha\gets $ user defined weighting value
		\If{$otherTarget.lastUpdateTime > myTarget.lastUpdateTime$}
			\State $myTarget.heading\gets alpha * otherTarget.heading + (1-alpha)*myTarget.heading$
			\State \Call{InterpolateCoordinate}{$myTarget.location, otherTarget.location, alpha$}
			\For{$i\gets 0, $ number of target types}
				\State $myTarget.probTypes[i]\gets alpha * otherTarget.probTypes[i] + (1-alpha)*myTarget.probTypes[i]$
			\EndFor
			\State $myTarget.lastUpdateTime\gets otherTarget.lastUpdateTime$
		\EndIf
		\EndFunction
		\\
		\Function{InterpolateCoordinate}{from, to, percentage}
			\State $deltaNorth\gets to.north - from.north$
			\State $deltaEast\gets to.east - from.east$
			\State $from.north\gets from.north + deltaNorth * percentage$
			\State $from.east\gets from.east + deltaEast * percentage$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Target Task Status Merging}
	\label{alg:mergeTaskStatus}
	\begin{algorithmic}[1]
		\Function{MergeTargetTaskStatus}{$myTask, otherTask$}
		\State $copyMonitorData\gets false$
		\State $copyAttackData\gets false$
		\\
		\If{$otherTask.monitorState == Complete and myTask.monitorState != otherTask.monitorState$}
			\State $copyMonitorData\gets true$
			\Comment Another UAV completed the task
		\ElsIf{$otherTask.monitorScore > myTask.monitorScore and otherTask.monitorState != Complete and myTask.monitorState != Complete$}
			\State $copyMonitorData\gets true$
			\Comment Everyone is bidding on the task still
		\EndIf
		\\
		\If{$copyMonitorData == true$}
			\State $myTask.monitorID\gets otherTask.monitorID$
			\State $myTask.monitorScore\gets otherTask.monitorScore$
			\State $myTask.monitorState\gets otherTask.monitorState$
			\State $myTask.monitorTimestamp\gets otherTask.monitorTimestamp$									
		\EndIf
		\\
		\If{$otherTask.attackState == Complete and myTask.attackState != otherTask.attackState$}
			\State $copyAttackData\gets true$
			\Comment Another UAV completed the task
		\ElsIf{$otherTask.attackScore > myTask.attackScore and otherTask.attackState != Complete and myTask.attackState != Complete$}
			\State $copyAttackData\gets true$
			\Comment Everyone is bidding on the task still
		\EndIf
		\\
		\If{$copyAttackData == true$}
			\State $myTask.attackID\gets otherTask.attackID$
			\State $myTask.attackScore\gets otherTask.attackScore$
			\State $myTask.attackState\gets otherTask.attackState$
			\State $myTask.attackTimestamp\gets otherTask.attackTimestamp$
			\State $myTask.destroyed\gets otherTask.destroyed$					
		\EndIf

		\EndFunction
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{Task Allocation}
	\label{alg:taskAlloc}
	\begin{algorithmic}[1]
		\State $attackBids \gets $Null Set
		\State $monitorBids \gets $Null Set
		\\
		\If{attacking or monitoring}
			\State Update bid of current task
		\EndIf
		\\
		\For{all targets}
			\State $monitorBids[target] \gets$ compute monitor bid(target)
			\If{Target is pending an attack}
				\State $attackBids[target] \gets$ compute attack bid(target)
			\EndIf
		\EndFor
		\\
		\State $bestMonitorTgt = max(monitorBids)$
		\State $bestAttackTgt = max(attackBids)$
		\\
		\If{$bestAttackTgt$ not null and bid for $bestAttackTgt > $ current belief's task value for target}
			\State Update belief model with bid meta data
			\State Set current task to Attack
		\ElsIf{$bestMonitorTgt$ not null and bid for $bestMonitorTgt > $ current belief's task value for target}
			\State Update belief model with bid meta data		
			\State Set current task to Monitor			
		\Else
			\State Set current task to Search
		\EndIf
		
	\end{algorithmic}
\end{algorithm}
%------------------------------------------------------------------------------

\section{Data type models}
TBD
\todo{Create UML data type/structure models here.}