\chapter{Review of Literature}
\label{chap:relWork}
\section{Cooperative Swarms}

A paper in IEEE Transactions was the primary inspiration for the research described in this dissertation.  The paper describes a ``\ldots heterogeneous team of cooperating UAVs drawn from several distinct classes and engaged in a search and action mission over a spatially extended battlefield with targets of several types''~\parencite[p.571]{jin}.  They created a simulation of multiple cooperating UAVs searching for multiple targets.  Each type of UAV was suited for a particular category of tasks and each type of target had a corresponding task or set of tasks that had to be completed upon it.  Some targets had known locations and others had to be found via cooperative search.  Tasks to be completed in the environment were cooperatively assigned in real time as the mission progressed.  Their algorithm had to balance the need to explore and the need to complete tasks using the appropriate type of UAV.  The model incorporated realism by stochastically determining when targets were found and if tasks were completed successfully.

While the model in \textcite{jin} is fairly comprehensive, there is room for improvement.  Jin's model describes a military application of UAVs but assumes that the sensors are static and forward facing only.  Many military UAVs have gimbal mounted sensors.  The ability to aim the sensor without changing the trajectory of the host aircraft should affect the performance of task completion by the UAVs.  Lastly, the model is centralized but remarked as being convertible to a decentralized model.  The work in this thesis created a decentralized model.

%Their paper refers to the Pursuit-Evasion problem but thereâ€™s no evasion aspect to the model.  All the targets were statically located and never moved. 

\textcite{bellingham} from the Massachusetts Institute of Technology performed a similar experiment to \textcite{jin}.   They too combined path planning and task allocation.  Their work is different in that target locations are known \textit{a priori} and they wanted to minimize overall mission time.  The model in \textcite{jin} is a reactive model in that the UAVs actively explore the spatial area whereas the model in \textcite{bellingham} is proactive in that waypoints are generated between targets and UAVs before trajectories are planned.  A navigation graph is generated of all possible waypoints, target locations, and UAV locations and a search is run to find the shortest path between each UAV and all targets.  Then a task allocation algorithm is run to determine the most optimal UAV tasking based on time to completion and utilization of resources.  Neither model is superior to the other but each has a definitive purpose.  The model in \textcite{jin} is optimized for unstructured ad-hoc search type missions whereas the model in \textcite{bellingham} is optimized for structured quick strike type missions.

Another group combined path planning and task assignment in \textcite{beard}.  Their model is different from \textcite{jin} and \textcite{bellingham} because they had only a single set of targets and all tasks were known \textit{a priori}.  The goal of \textcite{beard} was to create cooperative assignments such that multiple vehicles complete the same task(s) simultaneously.  The idea was to model a surprise attack situation in which multiple UAVs strike multiple targets at once giving preference to assigning multiple UAVs to strike high value targets.  The model generated teams of UAVs, assigned them to targets, and generated flight paths such that all UAVs arrived at their targets at the same time while avoiding localized short-range anti-air defenses.



\textcite{jin}, \textcite{bellingham}, and \textcite{beard} have all carried out software simulations for their models and make assumptions about the real world and the ability of UAVs to fly in close proximity without issue.  The ScanEagle manufacturer \textcite{insitu_brochure} and a group of universities teamed up to create a flock of UAVs that could pursue and track a moving ground target in \textcite{wheeler} based off earlier work in~\textcite{wise_rolf}.  The Insitu ScanEagle is one of the smallest military UAVs with an inertially stabilized gimbaled camera.  Ideally, combining multiple sensors readings from different perspectives of the same target should create a more accurate measurement than a single sensor can provide.  Their goal was to maintain a precise geo-location track of the target and generate a history of its locations.  Their simulation and flight tests prove that a small swarm (or flock) of UAVs can cooperatively fly closely together without colliding while exchanging information.  The exchanged information included flight trajectories and data about the target. 

The biggest drawback of the work conducted by \textcite{jin}, \textcite{bellingham}, \textcite{beard}, and \textcite{wheeler} is that all of their models are centralized even though they use swarms.  There is a single routing point for all of the information about the world, tasks, targets, and UAVs.  This means there is a single point of a failure and this single point is a computational bottleneck limiting the swarm's performance.  To support centralized control systems requires a complete unbroken communication network from all members of the swarm back to the central control node.  Creating such a communication network can be a challenging task particularly in battlefield and emergency response situations where swarming is very beneficial.  A decentralized system does not have a single point of failure and allows the swarm to continue to function in communication limited or denied environments which greatly increases the real-world applicability of the system.  A decentralized system also improves the number of tasks that can be completed in a given timespan compared to a centralized running at the same time as shown in ~\textcite{chien} due to the parallel nature saving computation time.  

\section{Types of Swarms}
\label{sec:types_swarms}
A swarm taxonomy is presented in~\textcite{iridia} that helps to describe and compare different swarming techniques and goals. The taxonomy has 3 top level categories, \textit{Spatially Organizing Behaviors}, \textit{Navigation Behaviors}, and \textit{Collective Decision Making}.  \textit{Spatially Organizing Behaviors} type swarms focus on maintaining a localized structured spacing between neighbors in the swarm such as in escorting or formation flight.  \textit{Navigation Behaviors} type swarms focus on global swarm spacing between neighbors to optimize mission area coverage.  \textit{Collective Decision Making} type swarms focus on optimizing some global metric regardless of geospatial constraints.

Using this taxonomy the model in ~\textcite{jin} is a subtype of \textit{Navigation Behaviors} swarms called a \textit{collective exploration} because this swarm focuses on exploring the mission area without knowing about target locations \textit{a priori}.  The model in \textcite{bellingham} is a subtype of \textit{Collective Decision Making} swarm called \textit{task allocation}  because it knows about targets \textit{a priori} and coordinates the control of all swarm members to optimize a global metric for target interactions.  Although \textcite{beard} is similar to \textcite{bellingham} in that targets are known beforehand and they try to optimize swarm tasking allocation they have an additional important constraint.  The swarming mission in \textcite{beard} requires all swarm members to coordinate their motion such that they all complete their tasks at the same time for a surprise attack. This geospatial constraint means the swarm is a subtype of \textit{Navigation Behaviors} called \textit{coordinated motion}.  The swarm in \textcite{wheeler} is a subtype of \textit{Spatially Organizing Behaviors} swarms called \textit{self-assembly and morphogenesis} because it focuses on formation flight to orbit around a moving ground target. % The research described in this thesis builds upon these previous groups and more but creates a decentralized system that performs a \textit{collective exploration} since periodic exploration of the mission area is part of the control logic and targets are not known beforehand.

The taxonomy in ~\textcite{iridia} is useful but it can only be applied at a generalized high level or we must augment it to capture an important criteria.  The taxonomy splits its top level categories broadly on if the swarm focuses on formation flight, world area coverage, or if the swarm disregards geospatial geometry to focus solely on a performance metric.  It makes no distinction between centralized and decentralized swarming methodologies.  Each of these classification categories could be handled by a centralized or decentralized swarm so that's not a deciding factor in the taxonomy.  However, these categories are incomplete without specifying the implementation.  Therefore when we categorize a swarming system we can use this taxonomy but we must also state whether it is a centralized or decentralized system.  All of the previously discussed groups (\textcite{jin}, \textcite{bellingham}, \textcite{beard}, and \textcite{wheeler})  all created centralized swarms.

\section{Task Allocation}
\label{sec:uncoordTaskingRelated}

Assigning tasks amongst a group of workers is a well-known problem with many facets and variants \parencite{hungarian_method, hungarian_tribute, gen_asgn_prob1, gen_asgn_prob2}. The academic fields of Operations Research and Queuing Theory deal with this problem in detail \parencite{queue_theory_book}.  In our case we have a group of UAVs with different capabilities.  The UAVs coordinate and cooperate but there is no centralized controller or manager.   

%In theory, having a centralized controller with perfect information could produce the most optimal configuration of task allocations for the entire swarm.  In practice, achieving such a system is difficult since it requires a large amount of communication and introduces a single point of failure.  

Algorithms and heuristics that create an optimal solution given perfect information can take a long time to run.  Thus, even if we have a suitable communications network the responsiveness of the centralized controller introduces another potential problem especially as the size of the swarm or number of potential tasks increases. \parencite{heuristic_performance}

Fully decentralized controllers cannot guarantee perfectly optimal task allocations but they can usually provide ``good enough'' allocations.  An example of this is proven in~\textcite{auction_linear_approx} where the distributed algorithm came within a linear approximation of the perfect global optimum solution.  Decentralized controllers use imperfect local knowledge and can operate very fast in comparison to centralized controllers due to their inherent parallelism.  Decentralized controllers also offer failure redundancy and reductions in performance requirements of the communications network.

Two common approaches to distributed task allocation are market based algorithms and behavioral algorithms \parencite{task_alloc_survey}.  On the spectrum from fully centralized to fully decentralized these algorithms lie somewhere in the middle in order to capitalize on the strengths of both approaches.

%\section{Market based allocation}
\subsection{Market based allocation}

The Auction Algorithm, as its name implies, borrows concepts from economics to model an auction \parencite{auction_book}.  A centralized version was proposed in~\textcite{auction_derive} and enhanced in later revisions by the same author.  The author created a distributed version of the Auction Algorithm in~\textcite{auction_parallel}.  The algorithm requires an agent to start an auction for some task to be completed.  Typically the agent that first detects a task starts the auction.  The agent broadcasts out a message with details about the task to the swarm.  Other agents then formulate a bid for the task and send their responses back to the auctioning agent.  The auctioneer waits for the bid responses and analyzes them.  The auctioneer could declare a winner or it could rebroadcast the current best bid and wait again for further responses with higher bids.  

%This is a generic description of the Auction Algorithm.  
There are many variants and derivatives of the Auction Algorithm that change how bids are generated, how the auction is closed, and how to handle communication failures.  There are even variants to allow multiple agents to perform a task together as a team in~\textcite{auction_team}.  The core feature of Auction Algorithms are the temporary centralized auctioneer per newly discovered task.  For these algorithms to function properly the auctioneer must be able to communicate with local agents and be able to compare their bid responses.  It also requires each agent to understand what it takes to accomplish every possible task.

Another market based system is the Contract Net protocol first introduced in~\textcite{contract_net}.  It could be considered a specialization or superset of the Auction Algorithm.  This protocol breaks a task into subtasks and allows each subtask to be auctioned independently. It defines a meta-language within the allocation process for describing tasks and the resources required to complete them.  It provides mechanisms for reporting on the status of tasks and returning information once a task in complete.  This allows more cooperation between agents and a potential for better global optimization since each sub-task can be performed by the best agent available instead of a single agent performing all subtasks within a task.  The trade-off for this better global optimum performance is a requirement for more communication to handle the subtask allocation and coordination.  As with the Auction Algorithm many variants of the Contract Net protocol have been created as described in~\textcite{contract_survey} and ~\textcite{contract_equity}.

In both market based systems there is a temporary communications channel and messaging sequence to support task allocation.  This is a detriment to communication constrained environments.

%\section{Behavior based allocation}
\subsection{Behavior based allocation}

Behavior based algorithms are algorithmic representations of phenomenon seen in humans and animals. They differ from the market based solutions in that agents ``take'' or ``volunteer'' for a task instead of being ``assigned'' a task.  For example in~\textcite{ant_colony_opt} a team of robots cooperated in a fully decentralized fashion and used the Ant Colony Optimization (originally created in ~\textcite{orig_aco}) algorithm for task allocation.  All of the robots were identical in form and function.  Tasks could require one or more robots.  Each robot used its own sensors to create a model of the environment and to generate a list of tasks to be accomplished.  A robot would then move about and observe a task.  It would then determine if enough robots were simultaneously working on a task together.  If so, then it would continue onwards toward another task, otherwise it would stop and help.  In this case no active communication occurred and tasks were passively taken.

Stigmergy is another common behavior based system \parencite{history_stigmergy} \parencite{social_cog_stigmergy}. In stigmergic systems data is not directly passed from one agent to the next.  Instead the environment is modified by the agents and in doing so data is encoded.  Other agents who then observe the modified environment will learn about the data left behind from the previous agent.  In~\textcite{stigmergy_building} a swarm of agents moved 2D blocks around to create a 2D structure.  No direct communication between the agents occurred.  Instead the agents were all programmed with rules indicating if they did not have a block that they should find one and if they have a block then they should find another collection of blocks that match some known pattern in their memory.  Once they found a pattern they dropped the block they were carrying to extend the collection or pattern.  In this fashion jumbled piles of blocks were turned into 2D structures.  In this case no active communication occurred and tasks were passively taken.

Another common example of behavior based task allocation are pheromone systems \parencite{p2p_pheromone, manet_pheromone}.  In these systems agents of the swarm deposit mechanical artifacts like in~\textcite{beacon_pheromone}, literal chemical pheromones such as in~\textcite{ethanol_swarm}, or more commonly a virtual pheromone.  Typically pheromone systems are created virtually by agents broadcasting a pheromone strength number in their belief models that are communicated with the rest of the swarm. The type of pheromone deposited indicates the type of task that can be performed at the location.  Over time these pheromones decay and disappear or seep into nearby locations.  The seepage of pheromones into nearby locations helps agents find and perform tasks by following the gradient of the pheromone's strength.

As with the other task allocation algorithms, there are many variants and techniques for handling the details of the pheromone system.  In~\textcite{pheromone} an ant colony was modeled in that the agents left the nest and foraged for food.  As the agents explored they left behind a ``to nest'' pheromone.  This pheromone helped guide the ant agents back to the nest.  When the ant agents found a source of food they would deposit a ``to food'' pheromone.  When the food carrying agents made it back to the nest by following the ``to nest'' gradient other ants would notice the newly deposited ``to food'' pheromone.  The other agents would then follow the ``to food'' pheromone to the food source and return to the nest therefore restrengthening the ``to food'' pheromone creating a positive feedback loop.  In this case active communication is used but tasks are passively acted upon by volunteers instead of being assigned.
%\textbf{TODO: Discuss TRA.pdf? Motivational behaviors?}

Behavior Based Allocation strategies can be less time efficient than Market Based Allocation systems since each swarm member must independently observe tasks in the environment whereas Market Based schemes explicitly communicate about all tasks.  The independent observation attribute of Behavior Based Allocation techniques means each individual UAV must observe that a task needs to be accomplished.  This means unless a task is within observation range a UAV may not necessarily know the task exists.  Market Based Allocation systems explicitly communicate that tasks exists and request other swarm members to compete for the task.  This means even if a task is not within observation range a UAV may be able to know a task exists.  Detailed comparisons on time performance between Behavior Based and Market Based task allocations are available in~\textcite{bba_vs_mba_1} and \textcite{bba_vs_mba_2}.

A benefit of Behavior Based Allocation over Market Based Allocation is that Behavior Based Allocation can be accomplished without the need for explicit bidirectional communication since no market style transactions need to occur.  For the purposes of this research a custom Behavior Based Allocation system is created and explained in section~\ref{sec:uncoordTaskingMyWork} since this allocation type satisfies our goals of obtaining swarming behavior with minimal changes to legacy aircraft.